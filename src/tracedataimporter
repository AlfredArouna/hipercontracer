#!/usr/bin/python3
# -*- coding: utf-8 -*-
#
#  =================================================================
#           #     #                 #     #
#           ##    #   ####   #####  ##    #  ######   #####
#           # #   #  #    #  #    # # #   #  #          #
#           #  #  #  #    #  #    # #  #  #  #####      #
#           #   # #  #    #  #####  #   # #  #          #
#           #    ##  #    #  #   #  #    ##  #          #
#           #     #   ####   #    # #     #  ######     #
#
#        ---   The NorNet Testbed for Multi-Homed Systems  ---
#                        https://www.nntb.no
#  =================================================================
#
#  High-Performance Connectivity Tracer (HiPerConTracer)
#  Copyright (C) 2015-2016 by Thomas Dreibholz
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#  Contact: dreibh@simula.no

import os
import sys
import io
import datetime
import bz2
import shutil
import psycopg2
import configparser


# ###### Print log message ##################################################
def log(logstring):
   print('\x1b[32m' + datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S') + ': ' + logstring + '\x1b[0m');


# ###### Abort with error ###################################################
def error(logstring):
   sys.stderr.write(datetime.datetime.now().isoformat() + \
                    ' ===== ERROR: ' + logstring + ' =====\n')
   sys.exit(1)



# ###### Main program #######################################################
if len(sys.argv) < 2:
   error('Usage: ' + sys.argv[0] + ' database_configuration [-verbose]')

configFileName   = sys.argv[1]
transactionsPath = None
badFilePath      = None
dbServer         = 'localhost'
dbPort           = 5432
dbUser           = 'importer'
dbPassword       = None
dbName           = 'pingtraceroutedb'
verboseMode      = False

i = 2
while i < len(sys.argv):
   if sys.argv[i] == '-verbose':
      verboseMode = True
   else:
      error('Bad argument: ' + sys.argv[i])
   i = i + 1


# ====== Get parameters =====================================================
parsedConfigFile = configparser.RawConfigParser()
parsedConfigFile.optionxform = str   # Make it case-sensitive!
try:
   parsedConfigFile.readfp(io.StringIO('[root]\n' + open(configFileName, 'r').read()))
except Exception as e:
    error('Unable to read database configuration file' +  sys.argv[1] + ': ' + str(e))
    sys.exit(1)

for parameterName in parsedConfigFile.options('root'):
   parameterValue = parsedConfigFile.get('root', parameterName)
   if parameterName == 'transactions_path':
      transactionsPath = parameterValue
   elif parameterName == 'bad_file_path':
      badFilePath = parameterValue
   elif parameterName == 'dbserver':
      dbServer = parameterValue
   elif parameterName == 'dbport':
      dbPort = parameterValue
   elif parameterName == 'dbuser':
      dbUser = parameterValue
   elif parameterName == 'dbpassword':
      dbPassword = parameterValue
   elif parameterName == 'database':
      dbName = parameterValue
   else:
      error('Unknown parameter ' + parameterName + ' in ' + sys.argv[1] + '!')

if not os.path.exists(transactionsPath):
   error('Invalid transactions path: ' + transactionsPath + '!')
try:
   os.mkdir(badFilePath)
except:
   pass
if not os.path.exists(badFilePath):
   error('Invalid bad file path: ' + badFilePath + '!')


# ====== Connect to the database ============================================
try:
   dbConnection = psycopg2.connect(host=str(dbServer), port=str(dbPort),
                                   user=str(dbUser), password=str(dbPassword),
                                   dbname=str(dbName))
   dbConnection.autocommit = False
except:
    log('Unable to connect to the database!')
    sys.exit(1)

dbCursor = dbConnection.cursor()


# ====== Import transactions ================================================
fileNumber             = 0
goodTransactions       = 0
badTransactions        = 0
firstTransaction       = True
transactionPackageSize = 64
notYetCommitted        = []


TDI_Bad     = 0
TDI_Aborted = 1
TDI_Good    = 2

_joinedTransaction = b''

def performLoadAndExecute(transactionFile):
   global _joinedTransaction

   transactionContent = None
   try:
      inputFile = bz2.BZ2File(transactionFile, 'r')
      transactionContent = inputFile.read()
   except:
      log('Transaction ' + transactionFile + ' cannot be read -> moving it to bad file directory')
      try:
         shutil.move(transactionFile, badFilePath)
      except Exception as e:
         error('Unable to move bad transaction ' + transactionFile + ' to ' + badFilePath + ': ' + str(e))

   # ------ Execute transaction ---------------------------------------------
   if transactionContent != None:
      _joinedTransaction = _joinedTransaction + transactionContent
      # print("T="+str(len(_joinedTransaction.decode("utf-8"))))

   return TDI_Good

def performCommit():
   global _joinedTransaction

   # ------ Commit transaction ----------------------------------------------
   try:
      # print("X="+str(len(_joinedTransaction.decode("utf-8"))))
      dbCursor.execute(b'BEGIN TRANSACTION;\n' + _joinedTransaction + b'\nEND TRANSACTION;\n')
      dbConnection.commit()

   # ------ Handle exception -> rollback ------------------------------------
   except KeyboardInterrupt:
      # ------ Interrupted by user ---------------------------------------
      log('Interrupted by user.')
      dbConnection.rollback()
      return TDI_Aborted

   except Exception as e:

      # ------ Connection is broken -----------------------------------------
      if ( (dbConnection.closed) or ("SSL SYSCALL error" in str(e)) ):
         # Need to check for "SSL SYSCALL errors", since psycopg2
         # does not detect connection breaks properly.
         # See https://bitbucket.org/zzzeek/sqlalchemy/issues/3021/ssl-eof-not-detected-as-disconnect-in
         log('The database connection seems to be closed. Aborting import!')
         return TDI_Aborted

      # ------ Other problem (e.g. bad SQL statements, etc. -----------------
      log('Transaction cannot be executed or committed: ' + str(e))
      dbConnection.rollback()
      _joinedTransaction = b''
      return TDI_Bad

   _joinedTransaction = b''
   return TDI_Good


def performRemoval(completedTransactionFiles):
   for completedTransactionFile in completedTransactionFiles:
      try:
         if os.path.exists(completedTransactionFile):
            os.remove(completedTransactionFile)
      except Exception as e:
         error('Unable to remove completed transaction ' + completedTransactionFile + ': ' + str(e))


# ====== Perform import =====================================================
notYetCommitted     = []
transactionFileList = [ file for file in os.listdir(transactionsPath) if os.path.isfile(os.path.join(transactionsPath, file)) ]
transactionFileList.sort()   # (key = lambda x: os.path.getmtime(x))
for transactionFile in transactionFileList:
   absTransactionFile = os.path.join(transactionsPath, transactionFile)
   if os.path.isfile(absTransactionFile):
      if firstTransaction:
         firstTransaction = False
         log('Starting import of new transactions ...')

      # ------ Read transactions from file ----------------------------------
      notYetCommitted.append(absTransactionFile)
      fileNumber = fileNumber + 1
      if verboseMode == True:
         log('Importing ' + absTransactionFile +
             ' (' + str(fileNumber) + ' of ' + str(len(transactionFileList)) + ') as #' + str(len(notYetCommitted)) + ' in package ...')

      executeStatus = performLoadAndExecute(absTransactionFile)
      commitStatus  = TDI_Good
      # ------ Aborted -----------------------------------------
      if executeStatus == TDI_Aborted:
         break
      # ------ Good --------------------------------------------
      elif executeStatus == TDI_Good:
         if ((len(notYetCommitted) >= transactionPackageSize) or
             (fileNumber >= len(transactionFileList))):
            commitStatus = performCommit()
            if commitStatus == TDI_Aborted:
               break
            elif commitStatus == TDI_Good:
               goodTransactions = goodTransactions + len(notYetCommitted)
               performRemoval(notYetCommitted)
               notYetCommitted = []
               if verboseMode == True:
                  log('Committed transaction package.')

      # ------ Error -------------------------------------------
      if ((executeStatus == TDI_Bad) or (commitStatus == TDI_Bad)):
         if len(notYetCommitted) == 1:
            # ------ Move bad transaction file -----------------
            log('Transaction ' + notYetCommitted[0] + ' cannot be performed -> moving it to bad file directory')
            try:
               shutil.move(notYetCommitted[0], badFilePath)
            except Exception as e:
               error('Unable to move bad transaction ' + notYetCommitted[0] + ' to ' + badFilePath + ': ' + str(e))
            badTransactions = badTransactions + 1
            notYetCommitted = []

         else:
            # ------ Repeat transactions to find problem -------
            if verboseMode == True:
               log('Entering single-transaction mode!')
            for transactionFile in notYetCommitted:
               if verboseMode == True:
                  log('Retrying to import ' + transactionFile + ' ...')
               executeStatus = performLoadAndExecute(transactionFile)
               commitStatus  = TDI_Good
               # ------ Aborted --------------------------------
               if executeStatus == TDI_Aborted:
                  log('Aborted.')
                  break
               # ------ Good -----------------------------------
               if executeStatus == TDI_Good:
                  commitStatus = performCommit()
                  if commitStatus == TDI_Aborted:
                     log('Aborted.')
                     break
                  elif commitStatus == TDI_Good:
                     goodTransactions = goodTransactions + 1
                     performRemoval([ transactionFile ])

               if ((executeStatus == TDI_Bad) or (commitStatus == TDI_Bad)):
                  log('Transaction ' + transactionFile + ' cannot be performed -> moving it to bad file directory')
                  try:
                     shutil.move(transactionFile, badFilePath)
                  except Exception as e:
                     error('Unable to move bad transaction ' + transactionFile + ' to ' + badFilePath + ': ' + str(e))
                  badTransactions = badTransactions + 1

            notYetCommitted = []
            if verboseMode == True:
               log('Leaving single-transaction mode!')


# ====== All done! ==========================================================
log(str(goodTransactions) + ' transactions committed, ' + str(badTransactions) + ' were bad.')
